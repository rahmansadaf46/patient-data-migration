const { mysqlPool, inventoryPostgresPool } = require('../config/database');
const { dateFormat } = require('../utils/dateUtils');
const { v4: uuidv4 } = require('uuid');
const logger = require('../config/logger');
const config = require('../config/env');

class InventoryService {
  async createInventoryTableIfNotExists() {
    const client = await inventoryPostgresPool.connect();
    try {
      // Check if the 'inventory' schema exists
      const schemaCheck = await client.query(
        `SELECT EXISTS (
          SELECT FROM pg_namespace 
          WHERE nspname = 'inventory'
        )`
      );
  
      if (!schemaCheck.rows[0].exists) {
        logger.info('Creating inventory schema...');
        await client.query(`CREATE SCHEMA inventory`);
        logger.info('Schema inventory created successfully.');
      }
  
      // Check if the 'inventory_products' table exists
      const tableCheck = await client.query(
        `SELECT EXISTS (
          SELECT FROM pg_tables 
          WHERE schemaname = 'inventory' AND tablename = 'inventory_products'
        )`
      );
  
      if (!tableCheck.rows[0].exists) {
        logger.info('Creating inventory.inventory_products table...');
        await client.query(`
          CREATE TABLE IF NOT EXISTS inventory.inventory_products (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            product_id UUID NOT NULL DEFAULT gen_random_uuid(),
            hospital_id UUID NOT NULL,
            organization_id UUID NOT NULL,
            product_name VARCHAR(255) NOT NULL,
            unit_of_measure VARCHAR(50),
            product_description TEXT,
            category VARCHAR(50) NOT NULL,
            uuid UUID DEFAULT gen_random_uuid() UNIQUE,
            created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITHOUT TIME ZONE,
            created_by VARCHAR(50),
            updated_by VARCHAR(50),
            status VARCHAR(50) DEFAULT 'ACTIVE',
            reason_to_update TEXT,
            reason_to_delete TEXT
          );
        `);
        logger.info('Table inventory.inventory_products created successfully.');
      }
    } catch (error) {
      logger.error('Error creating inventory_products table', { error: error.message });
      throw error;
    } finally {
      client.release();
    }
  }

  async migrateInventory() {
    await this.createInventoryTableIfNotExists();

    const limit = 1000;
    let offset = 0;
    let totalMigrated = 0;
    const skippedItems = [];

    while (true) {
      const [inventoryItems] = await mysqlPool.query(
        `
        SELECT
          ii.name AS product_name,
          iss.name AS unit_of_measure,
          iic.name AS category,
          ii.created_on AS created_at
        FROM
          inventory_item ii
        LEFT JOIN
          inventory_item_category iic ON ii.category_id = iic.id
        LEFT JOIN
          inventory_item_specifications iis ON ii.id = iis.item_id
        LEFT JOIN
          inventory_item_specification iss ON iis.specification_id = iss.id
        LIMIT ? OFFSET ?
        `,
        [limit, offset]
      );

      if (inventoryItems.length === 0) break;

      const client = await inventoryPostgresPool.connect();
      try {
        await client.query('BEGIN');

        for (const item of inventoryItems) {
          const productId = uuidv4();

          const inventoryData = {
            product_id: productId,
            hospital_id: config.get('hospital_id') || uuidv4(),
            organization_id: config.get('organization_id') || uuidv4(),
            product_name: item.product_name ? item.product_name.trim() : 'Unknown',
            unit_of_measure: item.unit_of_measure && item.unit_of_measure.length < 50 ? item.unit_of_measure.trim() : null,
            product_description: item.unit_of_measure && item.unit_of_measure.length > 50 ? item.unit_of_measure.trim() : null,
            category: item.category === 'Consumables' ? 'CONSUMABLE' : 'EQUIPMENT',
            created_at: dateFormat(item.created_at) || new Date(),
            status: 'ACTIVE',
          };

          // Check for duplicate based on product_name, unit_of_measure, product_description, and category
          const existingProduct = await client.query(
            `
            SELECT id FROM inventory.inventory_products 
            WHERE product_name = $1 
              AND (unit_of_measure = $2 OR (unit_of_measure IS NULL AND $2 IS NULL))
              AND (product_description = $3 OR (product_description IS NULL AND $3 IS NULL))
              AND category = $4
            `,
            [
              inventoryData.product_name,
              inventoryData.unit_of_measure,
              inventoryData.product_description,
              inventoryData.category,
            ]
          );

          if (existingProduct.rows.length > 0) {
            // Skip insertion if duplicate is found
            skippedItems.push({
              product_name: inventoryData.product_name,
              unit_of_measure: inventoryData.unit_of_measure,
              product_description: inventoryData.product_description,
              category: inventoryData.category,
              reason: 'Duplicate product'
            });
            continue;
          }

          // Insert if no duplicate is found
          await client.query(
            `
            INSERT INTO inventory.inventory_products (
              product_id, hospital_id, organization_id, product_name, unit_of_measure,
              product_description, category, created_at, status
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            `,
            [
              inventoryData.product_id,
              inventoryData.hospital_id,
              inventoryData.organization_id,
              inventoryData.product_name,
              inventoryData.unit_of_measure,
              inventoryData.product_description,
              inventoryData.category,
              inventoryData.created_at,
              inventoryData.status,
            ]
          );

          totalMigrated++;
        }

        await client.query('COMMIT');
      } catch (error) {
        await client.query('ROLLBACK');
        logger.error('Error during inventory migration batch', { error: error.message });
        throw error;
      } finally {
        client.release();
      }

      offset += limit;
    }

    logger.info('Inventory migration completed.', { totalMigrated, skippedItemsCount: skippedItems.length, skippedItems });
    return { totalMigrated, skippedItems };
  }
}

module.exports = new InventoryService();